<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lombok注解的使用</title>
    <url>/posts/8340b4fb.html</url>
    <content><![CDATA[<h3 id="POJO类常用注解"><a href="#POJO类常用注解" class="headerlink" title="POJO类常用注解:"></a>POJO类常用注解:</h3><p><strong>@Getter/@Setter: 作用类上，生成所有成员变量的getter/setter方法；作用于成员变量上，生成该成员变量的getter/setter方法。可以设定访问权限及是否懒加载等。</strong></p>
<p><strong>@ToString：作用于类，覆盖默认的toString()方法，可以通过of属性限定显示某些字段，通过exclude属性排除某些字段。</strong></p>
<a id="more"></a>
<p><strong>@EqualsAndHashCode：作用于类，覆盖默认的equals和hashCode</strong></p>
<p><strong>@NonNull：主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常。</strong></p>
<p><strong>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor：作用于类上，用于生成构造函数。有staticName、access等属性。</strong></p>
<p><strong>staticName属性一旦设定，将采用静态方法的方式生成实例，access属性可以限定访问权限。</strong></p>
<p><strong>@NoArgsConstructor：生成无参构造器；</strong></p>
<p><strong>@RequiredArgsConstructor：生成包含final和@NonNull注解的成员变量的构造器；</strong></p>
<p><strong>@AllArgsConstructor：生成全参构造器</strong></p>
<p><strong>@Data：作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor</strong></p>
<p><strong>@Builder：作用于类上，将类转变为建造者模式</strong></p>
<p><strong>@Log：作用于类上，生成日志变量。针对不同的日志实现产品，有不同的注解：</strong></p>
<h3 id="其他重要注解："><a href="#其他重要注解：" class="headerlink" title="其他重要注解："></a>其他重要注解：</h3><p><strong>@Cleanup：自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如：典型的IO流对象</strong></p>
<p><strong>@SneakyThrows：可以对受检异常进行捕捉并抛出，可以改写上述的main方法如下：</strong></p>
<p><strong>@Synchronized：作用于方法级别，可以替换synchronize关键字或lock锁，用处不大.</strong></p>
]]></content>
      <categories>
        <category>Lombok</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>Lombok</tag>
        <tag>注解</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-mapper</title>
    <url>/posts/886e92c3.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mapper</category>
        <category>mybatis插件</category>
      </categories>
      <tags>
        <tag>mapper</tag>
        <tag>mybatis插件</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex 学习</title>
    <url>/posts/e61720a.html</url>
    <content><![CDATA[<h1 id="Vuex-是什么？"><a href="#Vuex-是什么？" class="headerlink" title="Vuex 是什么？"></a>Vuex 是什么？</h1><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>这个状态自管理应用包含以下几个部分：</p>
<ul>
<li>state，驱动应用的数据源；</li>
<li>view，以声明方式将 state 映射到视图；</li>
<li>actions，响应在 view 上的用户输入导致的状态变化。</li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ol>
<li>vuex管理的状态对象</li>
<li>它应该是唯一的<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    xxx: initValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><ol>
<li>包含多个直接更新state的方法(回调函数)的对象</li>
<li>谁来触发：action中的commit(‘mutation名称’)</li>
<li>只能包含同步的代码，不能写异步代码<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    yyy (state, data) &#123;</span><br><span class="line">        <span class="comment">// 更新state的某个属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><ol>
<li>包含多个事件回调函数的对象</li>
<li>通过执行：commit()来触发mutation的调用,间接更新state</li>
<li>谁来触发：组件中：$store.dispatch(‘action名称’, data1) //‘zzz’</li>
<li>可以包含异步代码（定时器，ajax）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    zzz(&#123;commit, state&#125;, data1) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;yyy&#x27;</span>, &#123;data1&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><ol>
<li>包含多个计算属性（get）的对象</li>
<li>谁来读取： 组件中： $store.getters.xxx<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    mmm (state) &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><ol>
<li>包含多个module</li>
<li>一个module是一个store的配置对象</li>
<li>与一个组件（包含有共享数据）对应</li>
</ol>
<h3 id="向外暴露store对象"><a href="#向外暴露store对象" class="headerlink" title="向外暴露store对象"></a>向外暴露store对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="组件中"><a href="#组件中" class="headerlink" title="组件中"></a>组件中</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125;  <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">&#x27;./TodoItem.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([<span class="string">&#x27;todos&#x27;</span>])</span><br><span class="line">&#125;,</span><br><span class="line">components: &#123;</span><br><span class="line">  TodoItem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="映射store"><a href="#映射store" class="headerlink" title="映射store"></a>映射store</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="store对象"><a href="#store对象" class="headerlink" title="store对象"></a>store对象</h3><ol>
<li>所有用vuex管理的组件中都多了一个属性$store，它就是一个store对象</li>
<li>属性<ul>
<li>state:注册的state对象</li>
<li>getters:注册的getters对象</li>
</ul>
</li>
<li>方法<br>dispath(actionName,data):分发调用action</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 分析</title>
    <url>/posts/48d08c37.html</url>
    <content><![CDATA[<h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><ol>
<li>数据代理：通过一个对象代理对另一个对象中属性的操作（读）</li>
<li>vue数据代理：通过vm对象来代理data对象中所有属性的操作</li>
<li>好处：更方便的操作data中的数据</li>
<li>基本实现流程<ol>
<li>通过Object.defineProperty()给vm添加与data对象的属性对应的属性描述符</li>
<li>所有添加的属性都包含getter/setter</li>
<li>getter/setter 内部去操作data中对应的属性数据</li>
</ol>
</li>
</ol>
<hr>
<h2 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h2><h3 id="模板解析的基本流程"><a href="#模板解析的基本流程" class="headerlink" title="模板解析的基本流程"></a>模板解析的基本流程</h3><ol>
<li>将el的所有子节点取出，添加到一个新建的文档fragment对象中</li>
<li>将fragment中的所有层次子节点递归进行编译解析处理<ul>
<li>对大括号表达式文本节点进行解析</li>
<li>对元素节点的指令属性进行解析<ul>
<li>事件指令解析</li>
<li>一般指令解析</li>
</ul>
</li>
</ul>
</li>
<li>将解析后的fragment添加到el中显示</li>
</ol>
<h3 id="大括号表达式解析"><a href="#大括号表达式解析" class="headerlink" title="大括号表达式解析"></a>大括号表达式解析</h3><ol>
<li>根据正则对象得到匹配出的表达式字符串：自匹配/RegExp.$1</li>
<li>从data中取出表达式对应的属性值</li>
<li>将属性值设置为文本节点的textContent</li>
</ol>
<h3 id="事件指令解析"><a href="#事件指令解析" class="headerlink" title="事件指令解析"></a>事件指令解析</h3><ol>
<li>从指令名中取出事件名</li>
<li>根据指令的值（表达式）从methods中得到对应的事件处理函数对象</li>
<li>给当前元素节点绑定指定事件名和回调函数的dom事件监听</li>
<li>指令解析完后，移除此指令属性</li>
</ol>
<h3 id="一般指令解析"><a href="#一般指令解析" class="headerlink" title="一般指令解析"></a>一般指令解析</h3><ol>
<li>得到指令名和指令值（表达式） ：text/html/class msg/myClass</li>
<li>从data中根据表达式得到对应的值</li>
<li>根据指令名确定需要操作元素节点的什么属性<ul>
<li>v-text—textContent属性</li>
<li>v-html—innerHTML属性</li>
<li>v-class—className属性</li>
</ul>
</li>
<li>将得到的表达式的值设置到对应的属性上</li>
<li>移除元素的指令属性</li>
</ol>
<hr>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="数据绑定-1"><a href="#数据绑定-1" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>一旦更新了data中的某个属性数据，所有界面上直接使用或间接使用了此属性的节点都会更新</p>
<h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><ol>
<li>数据劫持是vue中用来实现数据绑定的一种技术</li>
<li>基本思想：通过defineProperty()来监视data中所有属性（任意层次）数据的变化，一旦变化就去更新界面</li>
</ol>
<h3 id="四个重要对象"><a href="#四个重要对象" class="headerlink" title="四个重要对象"></a>四个重要对象</h3><ol>
<li><p>Observer</p>
</li>
<li><p>Dep<br>它的实例什么时候创建？</p>
<pre><code>答：初始化时给data的属性进行数据劫持时创建的</code></pre>
<p>个数？</p>
<pre><code>答：与data中的属性一一对应</code></pre>
<p>Dep的结构？</p>
<pre><code>答：
id：标识
subs：[] n个相关的watcher的容器</code></pre>
</li>
<li><p>Compile</p>
</li>
<li><p>Watcher<br>它的实例什么时候创建？</p>
<pre><code>答：初始化解析大括号表达式/一般指令时创建</code></pre>
<p>个数？</p>
<pre><code>答：与模板中表达式（不包含事件指令）一一对应</code></pre>
<p>watcher的结构？</p>
<pre><code>答：
    this.cb = cb; //用于更新界面的回调
    this.vm = vm; // vm
    this.exp = exp; // 对应的表达式
    this.depIds = &#123;depid, dep&#125;; // 相关的n个dep的容器对象
    this.value = this.get(); // 当前表达式对应的value</code></pre>
</li>
</ol>
<h2 id="Dep与Watcher的关系"><a href="#Dep与Watcher的关系" class="headerlink" title="Dep与Watcher的关系"></a>Dep与Watcher的关系</h2><h3 id="什么关系？"><a href="#什么关系？" class="headerlink" title="什么关系？"></a>什么关系？</h3><pre><code>答：多对多的关系
    name ==&gt; Dep ==&gt; n个watcher（模板中有多个表达式使用了此属性：&#123;&#123;a&#125;&#125; v-text=&quot;a&quot;）
    表达式 ==&gt; Watcher ==&gt; n个Dep（多层表达式：a.b.c）</code></pre>
<h3 id="如何建立的？"><a href="#如何建立的？" class="headerlink" title="如何建立的？"></a>如何建立的？</h3><pre><code>答：data中属性的get()中建立</code></pre>
<h3 id="什么时候建立？"><a href="#什么时候建立？" class="headerlink" title="什么时候建立？"></a>什么时候建立？</h3><pre><code>答：初始化的解析模板中的表达式创建Watcher对象时
    vm.name = &#39;abc&#39; ==&gt; data中的name属性值变化 ==&gt; name的set()调用 ==&gt; dep ==&gt; 相关的所有watcher
     ==&gt; cb() ==&gt; updater</code></pre>
<h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><ol>
<li>双向数据绑定是建立在单向数据绑定（model ==&gt; View）的基础之上的</li>
<li>双向数据绑定的实现流程：<ol>
<li>在解析v-model指令时，给当前元素添加input监听</li>
<li>当input的value发生变化时，将最新的值赋值给当前表达式所对应的data属性</li>
</ol>
</li>
</ol>
<h2 id="MVVM结构图"><a href="#MVVM结构图" class="headerlink" title="MVVM结构图"></a>MVVM结构图</h2><p><img src="/images/mvvm.png" alt="MVVM结构图"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 常见面试题</title>
    <url>/posts/51b0f5df.html</url>
    <content><![CDATA[<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>面试题</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 常见面试题</title>
    <url>/posts/228e4888.html</url>
    <content><![CDATA[<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="什么是Spring框架？包含哪些主要模块？"><a href="#什么是Spring框架？包含哪些主要模块？" class="headerlink" title="什么是Spring框架？包含哪些主要模块？"></a>什么是Spring框架？包含哪些主要模块？</h2><blockquote>
<p>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。<br>主要模块： 核心容器、数据访问/集成、Web、AOP（面向切面编程）、工具、消息和测试模块</p>
</blockquote>
<hr>
<h2 id="使用Spring框架的好处？"><a href="#使用Spring框架的好处？" class="headerlink" title="使用Spring框架的好处？"></a>使用Spring框架的好处？</h2><ul>
<li>Dependency Injection（DI）方法使得构造器和JavaBean properties文件中的依赖关系一目了然</li>
<li>与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利</li>
<li>Spring利用了已有的技术，比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术</li>
<li>Spring框架是按照模块的形式来组织的。</li>
<li>Spring提供了一个便捷的事务管理接口</li>
<li>提供相应的测试环境代码</li>
</ul>
<hr>
<h2 id="什么是控制反转（IOC）？什么是依赖注入？"><a href="#什么是控制反转（IOC）？什么是依赖注入？" class="headerlink" title="什么是控制反转（IOC）？什么是依赖注入？"></a>什么是控制反转（IOC）？什么是依赖注入？</h2><p>在Java中依赖注入有三种实现方式：构造器注入，setter方法注入，接口注入</p>
<h2 id="BeanFactory和ApplicationContext-有什么区别？"><a href="#BeanFactory和ApplicationContext-有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext 有什么区别？"></a>BeanFactory和ApplicationContext 有什么区别？</h2><p>BeanFactory可以理解为含有bean集合的工厂类。BeanFactory包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。<br>BeanFactory还能在实例化对象时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法(initialization methods)和销毁方法(destruction methods)。<br>从表面上看，ApplicationContext如同BeanFactory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但ApplicationContext在此基础上还提供了其它的功能：</p>
<blockquote>
<ol>
<li>提供了支持国际化的文本消息</li>
<li>统一的资源文件读取方式</li>
<li>已在监听器中注册的bean的事件</li>
</ol>
</blockquote>
<p>以下是较常见的ApplicationContext实现方式：</p>
<ol>
<li>ClassPathXmlApplicationContext:从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>FileSystemXmlApplicationContext:由文件系统中的XML配置文件读取上下文。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>XmlWebApplicationContext:由Web应用的XML文件读取上下文。</li>
<li>AnnotationConfigApplicationContext(基于Java配置启动容器)</li>
</ol>
<hr>
<h2 id="Spring有几种配置方式？"><a href="#Spring有几种配置方式？" class="headerlink" title="Spring有几种配置方式？"></a>Spring有几种配置方式？</h2><p>将Spring配置到应用开发中有以下三种方式：</p>
<blockquote>
<p>1.基于XML的配置<br>2.基于注解的配置<br>3.基于Java的配置</p>
</blockquote>
<h3 id="如何用基于XML配置的方式配置Spring？"><a href="#如何用基于XML配置的方式配置Spring？" class="headerlink" title="如何用基于XML配置的方式配置Spring？"></a>如何用基于XML配置的方式配置Spring？</h3><p>========</p>
<h3 id="如何用基于Java配置的方式配置Spring？"><a href="#如何用基于Java配置的方式配置Spring？" class="headerlink" title="如何用基于Java配置的方式配置Spring？"></a>如何用基于Java配置的方式配置Spring？</h3><p>========</p>
<h3 id="如何用基于注解配置的方式配置Spring？"><a href="#如何用基于注解配置的方式配置Spring？" class="headerlink" title="如何用基于注解配置的方式配置Spring？"></a>如何用基于注解配置的方式配置Spring？</h3><p>========</p>
<h2 id="解释Spring-Bean的生命周期？"><a href="#解释Spring-Bean的生命周期？" class="headerlink" title="解释Spring Bean的生命周期？"></a>解释Spring Bean的生命周期？</h2><p>========</p>
<h2 id="Spring-Bean的作用域区别？"><a href="#Spring-Bean的作用域区别？" class="headerlink" title="Spring Bean的作用域区别？"></a>Spring Bean的作用域区别？</h2><p>5个范围</p>
<ol>
<li>singleton：是默认的，这种范围确保不管接受到多个请求，每个容器中只有一个bean的实例，单例的模式由beanFactory自身来维护</li>
<li>prototype：原型范围与单例范围相反，为每一个bean请求提供一个实例</li>
<li>request：在请求bean范围内会为每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li>
<li>session：与请求范围类似，确保每个session中有一个bean的实例，在session过去后，bean会随之失效。</li>
<li>global-session：global-session和Portlet应用有关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。<br>全局作用域与Servlet中的session作用域效果相同。</li>
</ol>
<h2 id="请举例说明如何在Spring中注入一个Java-Collection？"><a href="#请举例说明如何在Spring中注入一个Java-Collection？" class="headerlink" title="请举例说明如何在Spring中注入一个Java Collection？"></a>请举例说明如何在Spring中注入一个Java Collection？</h2><p>Spring提供了以下四种集合类的配置元素：</p>
<ul>
<li><code>&lt;list&gt;</code>: 该标签用来装配可重复的list值。</li>
<li><code>&lt;set&gt;</code>：该标签用来装配没有重复的set值。</li>
<li><code>&lt;map&gt;</code>：该标签可用来注入键和值可以为任何类型的键值对。</li>
<li><code>&lt;props&gt;</code>：该标签支持注入键和值都是字符串类型的键值对。</li>
</ul>
<h2 id="请解释自动装配模式的区别？"><a href="#请解释自动装配模式的区别？" class="headerlink" title="请解释自动装配模式的区别？"></a>请解释自动装配模式的区别？</h2><ul>
<li>no:这是Spring的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。</li>
<li>byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</li>
<li>byType：该选项可以根据bean的类型设置依赖关系。当想一个bean中自动装配一个属性时，容器将根据bean的类型自动在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</li>
<li>constructor：构造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器总没有找到与构造器参数类型一致的bean，那么将会抛出异常。</li>
<li>autodetect：该模式自动探测使用构造器自动装配或byType自动装配。首先，会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byType的自动装配方式。</li>
</ul>
<h2 id="如何开启基于注解的自动装配？"><a href="#如何开启基于注解的自动装配？" class="headerlink" title="如何开启基于注解的自动装配？"></a>如何开启基于注解的自动装配？</h2><p>要使用<code>@Autowired</code>，需要注册<code>AutowiredAnnotationBeanPostProcessor</code>，可以有以下两种方式来实现：</p>
<ol>
<li>引入配置文件中的<code>&lt;beans&gt;</code>下引入<code>&lt;context:annotation-config&gt;</code><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:annotation-config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li>在配置文件中直接引入<code>AutowiredAnnotationBeanPostProcessor</code><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;</span>&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 常见面试题</title>
    <url>/posts/8f175f96.html</url>
    <content><![CDATA[<h1 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h1><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<a id="more"></a>
<h1 id="Mybaits的优点"><a href="#Mybaits的优点" class="headerlink" title="Mybaits的优点"></a>Mybaits的优点</h1><ol>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</li>
<li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</li>
<li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</li>
<li>能够与Spring很好的集成；</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。    </li>
</ol>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="MyBatis与Hibernate有哪些不同"><a href="#MyBatis与Hibernate有哪些不同" class="headerlink" title="MyBatis与Hibernate有哪些不同"></a>MyBatis与Hibernate有哪些不同</h2><ol>
<li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</li>
<li>Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 </li>
<li>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 </li>
</ol>
<hr>
<h2 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么?"></a>#{}和${}的区别是什么?</h2><p> #{} 是预编译处理， ${} 是字符串替换。<br>Mybatis在处理 #{} 时，会将sql中的 #{} 替换为 ? 号，调用PreparedStatement的set方法来赋值；<br>Mybatis在处理 ${} 时，就是把 ${} 替换成变量的值。<br>使用 #{} 可以有效的防止SQL注入，提高系统安全性。    </p>
<hr>
<h2 id="当实体类中的属性名和表中的字段名不一样-，怎么办？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办？</h2><p>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”</span>&quot;<span class="attr">selectorder</span>&quot; <span class="attr">parametertype</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultetype</span>=<span class="string">&quot;top.jared.entity.order&quot;</span>&gt;</span></span><br><span class="line">    select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第2种： 通过<code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderresultmap&quot;</span>&gt;</span></span><br><span class="line">    select * from orders where order_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;top.jared.entity.order&quot;</span> <span class="attr">id</span>=<span class="string">&quot;orderresultmap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">!–用id属性来映射主键字段–</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orderno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_no&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_price&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写?"></a>模糊查询like语句该怎么写?</h2><p>第1种：在Java代码中添加sql通配符。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">String wildcardname = <span class="string">&quot;%smi%&quot;</span>;</span><br><span class="line">list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br><span class="line"> </span><br><span class="line">&lt;select id=<span class="string">&quot;selectlike&quot;</span>&gt;</span><br><span class="line"> select * from foo where bar like #&#123;value&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>第2种：在sql语句中拼接通配符，会引起sql注入</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">string wildcardname = <span class="string">&quot;smi&quot;</span>;</span><br><span class="line">list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br><span class="line"> </span><br><span class="line">&lt;select id=<span class="string">&quot;selectlike&quot;</span>&gt;</span><br><span class="line">     select * from foo where bar like <span class="string">&quot;%&quot;</span>$&#123;value&#125;<span class="string">&quot;%&quot;</span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h2><p>Dao接口即Mapper接口。接口的全限名，就是映射文件中的<code>namespace</code>的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。      </p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个MapperStatement对象。      </p>
<blockquote>
<p>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面 id 为 findStudentById 的 MapperStatement。</p>
</blockquote>
<hr>
<h2 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p>  Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。<br>  分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<hr>
<h2 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义数据库列名和对象属性名之间的映射关系。<br>第二种是使用sql列的别名功能，将列的别名书写为对象属性名。<br>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<hr>
<h2 id="如何执行批量插入"><a href="#如何执行批量插入" class="headerlink" title="如何执行批量插入?"></a>如何执行批量插入?</h2><p>首先,创建一个简单的insert语句:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertname&quot;</span>&gt;</span></span><br><span class="line">  insert into names(name) values(#&#123;value&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在java代码中像下面这样执行批处理插入: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list&lt;string&gt; names = <span class="keyword">new</span> arraylist();</span><br><span class="line">names.add(“fred”);</span><br><span class="line">names.add(“barney”);</span><br><span class="line">names.add(“betty”);</span><br><span class="line">names.add(“wilma”);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里 executortype.batch</span></span><br><span class="line">sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    namemapper mapper = sqlsession.getmapper(namemapper.class);</span><br><span class="line">    <span class="keyword">for</span> (string name : names) &#123;</span><br><span class="line">        mapper.insertname(name);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlsession.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    sqlSession.rollback(); </span><br><span class="line">    <span class="keyword">throw</span> e; </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    sqlsession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h2><p>insert 方法总是返回一个int值 ，这个值代表的是插入的行数。<br>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。<br>示例： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertname&quot;</span> <span class="attr">usegeneratedkeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyproperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into names (name) values (#&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name name = <span class="keyword">new</span> name();</span><br><span class="line">name.setname(<span class="string">&quot;fred&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rows = mapper.insertname(name);</span><br><span class="line"><span class="comment">// 完成后,id已经被设置到对象中</span></span><br><span class="line">system.out.println(<span class="string">&quot;rows inserted = &quot;</span> + rows);</span><br><span class="line">system.out.println(<span class="string">&quot;generated key value = &quot;</span> + name.getid());</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Mybatis</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka相关操作及报错</title>
    <url>/posts/18e29e3e.html</url>
    <content><![CDATA[<h3 id="启动zookeeper和kafka"><a href="#启动zookeeper和kafka" class="headerlink" title="启动zookeeper和kafka"></a>启动zookeeper和kafka</h3><a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">启动zookeeper</span><br><span class="line">nohup ./kafka_2.13-2.6.0/bin/zookeeper-server-start.sh ./kafka_2.13-2.6.0/config/zookeeper.properties &amp;</span><br><span class="line">启动kafka</span><br><span class="line">nohup ./bin/kafka-server-start.sh config/server.properties &amp;</span><br><span class="line"></span><br><span class="line">创建topic</span><br><span class="line">./bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic hello</span><br><span class="line">./bin/kafka-topics.sh --create --topic quickstart-events --bootstrap-server localhost:9092</span><br><span class="line">查看topic</span><br><span class="line">./bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br><span class="line">./bin/kafka-topics.sh --describe --topic quickstart-events --bootstrap-server localhost:9092</span><br><span class="line">生产消息</span><br><span class="line">./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic hello</span><br><span class="line">./bin/kafka-console-producer.sh --topic quickstart-events --bootstrap-server localhost:9092</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="报错解决方法"><a href="#报错解决方法" class="headerlink" title="报错解决方法"></a>报错解决方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建消费者时候报错：</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;kafka-console-consumer.sh --zookeeper localhost:2181 --topic hello --from-beginning</span><br><span class="line">zookeeper is not a recognized option</span><br><span class="line">问题原因：</span><br><span class="line">新版本kafka中，--zookeeper这种启动方式已删除。</span><br><span class="line">解决办法：</span><br><span class="line">0.90版本之后启动消费者的方法如下：</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;kafka-console-consumer.sh --bootstrap-server localhost:2181 --topic hello --from-beginning</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kafka</category>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
